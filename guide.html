<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Transducer Usage Guide</title>
    <link href="./images/s2.ico"                                   type="image/x-icon" rel="specs2 icon"/>
    <link href="./css/opensans-fonts.css"                          type="text/css"     rel="stylesheet" />
    <link href="./css/bootstrap.min.css"                           type="text/css"     rel="stylesheet" />
    <link href="./css/font-awesome.min.css"                        type="text/css"     rel="stylesheet" />
    <link href="./css/prettify.css"                                type="text/css"     rel="stylesheet" />
    <link href="./css/tabber.css"                                  type="text/css"     rel="stylesheet" />
    <link href="./css/tipuesearch.css"                             type="text/css"     rel="stylesheet" />
    <link href="./css/specs2.css"                                  type="text/css"     rel="stylesheet" />
    <link href="./css/specs2-user.css"                             type="text/css"     rel="stylesheet" />

    <script src="./javascript/jquery.js"                           type="text/javascript"></script>
    <script src="./javascript/jquery.jstree.js"                    type="text/javascript"></script>
    <script src="./javascript/tabber.js"                           type="text/javascript"></script>
    <script src="./javascript/tabber_start.js"                     type="text/javascript"></script>
    <script src="./javascript/prettify.js"                         type="text/javascript"></script>
    <script src="./javascript/specs2.js"                           type="text/javascript"></script>
    <script src="./javascript/specs2-user.js"                      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_set.js"      type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch_contents.js" type="text/javascript"></script>
    <script src="./javascript/tipuesearch/tipuesearch.min.js"      type="text/javascript"></script>

</head>
<body onload="prettyPrint()">

<div class="container">

<div class="col-md-2 sidebar-outer">
<div class="col-md-2 fixed">

<div class="col-md-1"></div>

<!-- table of contents -->
<div id="tree"><ul>
                <li id="guide"><a href="guide.html" title="Transducer Usage Guide">Transducer Usag...</a>
      <ul><ul><li><a href="guide.html#decoupling-from-in--and-output" title="Decoupling from in- and output">Decoupling from...</a>
          
        </li><li><a href="guide.html#composing-transducers" title="Composing Transducers">Composing Trans...</a>
          
        </li><li><a href="guide.html#laziness-and-early-termination" title="Laziness and early termination">Laziness and ea...</a>
          
        </li></ul></ul>
      <ul>
                    
                  </ul>
    </li>
              </ul></div><script>$(function () { $('#tree').jstree({'core':{'initially_open':['guide'], 'animation':200}, 'themes' : {'theme': 'default','url': './css/themes/default/style.css'}, 'plugins':['themes', 'html_data']}); });</script>

</div>
</div>


<div class="col-md-10">
<h1>Transducer Usage Guide</h1>
<div id="tipue_search_content"></div>

<p>Transducers are a way to build reusable transformations.</p>
<p>Let’s start with some input data <code class="prettyprint">xs</code>, that will be used for further examples:</p>
<pre><code class="prettyprint">(1 to 10).toList</code></pre>
<p><code class="prettyprint">&gt; List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)</code></p>
<p>And we will use this simple transducer <code class="prettyprint">tx</code>, that will filter out odd numbers:</p>
<pre><code class="prettyprint">transducers.filter((x: Int) ⇒ x % 2 == 0)</code></pre>
<p><code class="prettyprint">&gt; (filter)</code></p>
<h3 id="decoupling-from-in--and-output">Decoupling from in- and output</h3>
<p>A transducer is independent from its source or target. Notice how the definition of the transducer did not involve anything from the source or the target.</p>
<p>If you <code class="prettyprint">run</code> the transducer, it will use the input shape for the output.</p>
<ul><li class="example success ok"><code class="prettyprint">e1</code></li></ul>


<pre><code class="prettyprint">transducers.run(tx)(xs)</code></pre>
<p><code class="prettyprint">&gt; List(2, 4, 6, 8, 10)</code></p>
<p>You can also change the output shape using <code class="prettyprint">into</code>:</p>
<ul><li class="example success ok"><code class="prettyprint">e2</code></li></ul>


<pre><code class="prettyprint">transducers.into[Vector].run(tx)(xs)</code></pre>
<p><code class="prettyprint">&gt; Vector(2, 4, 6, 8, 10)</code></p>
<p>The shape has to be a first-order kinded type, i.e. <code class="prettyprint">F[_]</code> or <code class="prettyprint">* -&gt; *</code>. There must be an instance of <code class="prettyprint">AsTarget[F]</code> available. For some types, there is already an instance available.</p>
<pre><code class="prettyprint">(transducers.into[List].run(tx)(xs)
, transducers.into[Vector].run(tx)(xs)
, transducers.into[Stream].run(tx)(xs)
, transducers.into[Set].run(tx)(xs)
, transducers.into[Iterator].run(tx)(xs)
, transducers.into[Iterable].run(tx)(xs)
, transducers.into[Option].run(tx)(xs)
, transducers.into[Option](AsTarget.lastOption).run(tx)(xs)
)</code></pre>
<p><code class="prettyprint">&gt; (List(2, 4, 6, 8, 10),Vector(2, 4, 6, 8, 10),Stream(2, ?),Set(10, 6, 2, 8, 4),non-empty iterator,List(2, 4, 6, 8, 10),Some(2),Some(10))</code></p>
<p>Note that choosing <code class="prettyprint">Stream</code> won’t automatically stop the consumption of the input, when the stream is not consumed. Also, using <code class="prettyprint">Option</code> will not terminate the input consumption early. This might change in the future (PR welcome ;-) ).</p>
<p>If you already have some target data available, you can use <code class="prettyprint">addto</code>:</p>
<ul><li class="example success ok"><code class="prettyprint">e3</code></li></ul>


<pre><code class="prettyprint">val result = (-10 to 0 by 2).toVector
transducers.addto(result).run(tx)(xs)</code></pre>
<p><code class="prettyprint">&gt; Vector(-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10)</code></p>
<p>The same things about <code class="prettyprint">AsTarget</code> apply for <code class="prettyprint">addto</code> as they do for <code class="prettyprint">into</code>.</p>
<p>All three methods also support a variant where the arguments are reversed (<code class="prettyprint">(input)(transducer)</code>) which works better with type inference, if the transducer is declared inline:</p>
<pre><code class="prettyprint">transducers.run(transducers.filter((x: Int) ⇒ x % 2 == 0))(xs)
//  transducers.run(transducers.filter(_ % 2 == 0))(xs)  // wouldn&#39;t compile
transducers.run(xs)(transducers.filter(_ % 2 == 0))</code></pre>
<p><code class="prettyprint">&gt; List(2, 4, 6, 8, 10)</code></p>
<p><code class="prettyprint">into</code> and <code class="prettyprint">addto</code> also have a <code class="prettyprint">from</code> method, where you can define the input shape, and a transducer. You get a function from input to output:</p>
<ul><li class="example success ok"><code class="prettyprint">e4</code></li></ul>


<pre><code class="prettyprint">val fn: List[Int] ⇒ Vector[Int] = transducers.into[Vector].from[List].run(tx)
fn(xs)</code></pre>
<p><code class="prettyprint">&gt; Vector(2, 4, 6, 8, 10)</code></p>
<h3 id="composing-transducers">Composing Transducers</h3>
<p>Transducers can be composed as if they were functions (a <code class="prettyprint">Transducer[A, B]</code> is basically just a <code class="prettyprint">Reducer[B, _] ⇒ Reducer[A, _]</code>).</p>
<p>You can use <code class="prettyprint">compose</code> to create a new Transducer:</p>
<ul><li class="example success ok"><code class="prettyprint">e5</code></li></ul>


<pre><code class="prettyprint">val tx2 = transducers.map((_: Int) * 5)
val tx0 = tx compose tx2 // first map (*5), then filter (even?)

transducers.run(tx0)(xs)</code></pre>
<p><code class="prettyprint">&gt; List(10, 20, 30, 40, 50)</code></p>
<p>You can also use <code class="prettyprint">andThen</code></p>
<ul><li class="example success ok"><code class="prettyprint">e6</code></li></ul>


<pre><code class="prettyprint">val tx2 = transducers.map((_: Int) * 4)
val tx0 = tx andThen tx2 // first filter (even?), then map (*4)
transducers.run(tx0)(xs)</code></pre>
<p><code class="prettyprint">&gt; List(8, 16, 24, 32, 40)</code></p>
<p><code class="prettyprint">&gt;&gt;</code> is an alias for <code class="prettyprint">andThen</code></p>
<ul><li class="example success ok"><code class="prettyprint">e7</code></li></ul>


<pre><code class="prettyprint">val tx2 = transducers.map((_: Int) * 4)
val tx0 = tx &gt;&gt; tx2 // first filter (even?), then map (*4)
transducers.run(tx0)(xs)</code></pre>
<p><code class="prettyprint">&gt; List(8, 16, 24, 32, 40)</code></p>
<p>Instead of creating the transducers beforehand and fighting the type-inference, you directly chain transducers by calling the corresponding methods.</p>
<p>This way, the API looks like that of a collection type</p>
<ul><li class="example success ok"><code class="prettyprint">e8</code></li></ul>


<pre><code class="prettyprint">val tx0 = tx map (4 *) map (2 +) drop 4
transducers.run(tx0)(xs)</code></pre>
<p><code class="prettyprint">&gt; List(42)</code></p>
<h3 id="laziness-and-early-termination">Laziness and early termination</h3>
<p>Transducers are inherently lazy in their execution, similar to views. Unlike in normal collections, every step is executed in every transducer before the next value is computed.</p>
<p>To demonstrate this, the input is wrapped in an iterator <code class="prettyprint">it</code>, that counts how often it was consumed</p>
<pre><code class="prettyprint">CountingIterator(xs)</code></pre>
<p><code class="prettyprint">&gt; non-empty iterator</code></p>
<p>So, take terminates early if everything is taken</p>
<ul><li class="example success ok"><code class="prettyprint">e9</code></li></ul>


<pre><code class="prettyprint">val tx0 = tx.take(2)
(transducers.into[List].run(tx0)(it.it), it.consumed)</code></pre>
<p><code class="prettyprint">&gt; (List(2, 4),4)</code></p>
<p>Here, only 4 items were consumed (out of 10), because after 4 items, 2 were found that matched the filter and the process could be terminated.</p>
<p>Another effect of lazy evaluation is, that transducers can operate on infinite collections where the default scala collection operators would fail to terminate.</p>
<p>Consider this example in Scala:</p>
<pre><code class="prettyprint">Stream.from(1).dropRight(5).take(5)
// java.lang.OutOfMemoryError: GC overhead limit exceeded</code></pre>
<p>This works with transducers</p>
<ul><li class="example success ok"><code class="prettyprint">e10</code></li></ul>


<pre><code class="prettyprint">val xs = Stream.from(1)
val it = CountingIterator(xs)
val tx0 = tx.dropRight(5).take(5)

(transducers.into[List].run(tx0)(it.it), it.consumed)</code></pre>
<p><code class="prettyprint">&gt; (List(2, 4, 6, 8, 10),20)</code></p>
<p>20 Items are consumed, 10 of which pass the filter condition; 5 are buffered in case they need to be dropped and 5 will be taken until the process terminates.</p>
<p><br/><br/></p>
</div>

</div>

</body>
</html>